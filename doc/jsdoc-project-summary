
    
	<div class="section">
	<h3>About</h3>
    <p>
    	This document provides an overview of Sarissa along with examples of common tasks. 
    	The API documentation follows (thanks to <a href="http://jsdoc.sourceforge.net" title="Link to JSDoc project at SourceForge">JSDoc</a>).
    	This documentation is distributed under the GNU Free Documentation License (<a href="fdl.txt">fdl.txt</a>).
    </p>
    <p>
        The latest version of Sarissa can always be found on 
		<a href="https://sourceforge.net/projects/sarissa/" title="Link to Sarissa project at SourceForge">
		the Sourceforge project page.</a> Please send comments, corrections etc via email or the 
		<a href="https://sourceforge.net/forum/forum.php?forum_id=256492" title="Link to Sarissa forum at SourceForge.net">Sarissa forum.</a>. 
		
      </p>
      <p>
        Sarissa is distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher, 
        and GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher. In
		case your copy of Sarissa does not include the license texts, you may find
		them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a>.
      </p>
	  </div>
	  <div class="section">
	<h3>Gredits</h3>
	  <p>
	  Many thanks to Axel Hecht, Jonas Sicking, the folks at netscape.public.mozilla.* forums, Dimitre Novatchev, 
	  Ken Sall, Paul Everitt, Christian Stocker,  Marcus Andersson and Rob (Flaherty?). My deepest apologies to anyone I fail to mention;
	  please send over an email if your name should be here!
	  </p>
	  <p>
	  Sarissa was inspired by articles and code available on the web, most notably the 
	  <a href="http://webfx.eae.net/dhtml/ieemu/">IE Emu Series</a> [webfx.eae.net] at webfx and  
	  <a href="http://www.webreference.com/programming/javascript/domwrapper/">Cross-Browser DOM Wrapper article</a> [webreference.com].
	  </p>
	  <h3>Other projects</h3>
	  <p>
	  Dimitri Glazkov's XPath over HTML for MSIE (html-xpath) project at 
	  <a href="http://sourceforge.net/projects/html-xpath">http://sourceforge.net/projects/html-xpath</a> 
	  can be used as a complement to Sarissa. Moz already has DOM3 like HTML XPath support.
	  </p>
	  </div>
	  <div class="section">
	<h3>TOC</h3>
    <ul>
      <li>
        <a href="#overview">Oveview</a>
      </li>
      <li>
        <a href="#getxmldom">How to obtain a DOM Document Object</a>
      </li>
      <li>
        <a href="#getxmlhttp">How to obtain a XMLHTTP Request Object</a>
      </li>
      <li>
        <a href="#loadremote">How to load an DOM Document Object from a
            remote source</a>
        <ul>
          <li>
            <a href="#async">Asynchronous Loading</a>
          </li>
          <li>
            <a href="#sync">Synchronous Loading</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#loadstring">How to load an XML Document Object from an
            XML String</a>
      </li>
      <li>
        <a href="#parseerror">Checking for parsing errors</a>
      </li>
      <li>
        <a href="#transform">
        	How to transform an XML Document Object with XSLT
        </a>
        <ul>
          <li>
            <a href="#transformtoobject">
            	How to store the transformation result to a DOM object
            </a>
          </li>
          <li>
            <a href="#appendtopage">
            	How to insert the transformation result to a web page
            </a>
          </li>
          <li>
            <a href="#transformtostring">
            	How to store the transformation result to a String object
            </a>
          </li>
          <li>
            <a href="#xslparam">How to set XSLT parameters</a>
          </li>
          <li>
            <a href="#reusablexslt">How to reuse XSLT stylesheets through an XSLTProcessor</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#xpath">How to use XPath from JavaScript to select Nodes from an XML Document</a>
      </li>
    </ul>
	</div>
    <div class="section">
      <h3>
        <a id="overview">Oveview</a>
      </h3>
      <p>
            Sarissa is a JavaScript meta-API. It bridges the gap of DOM XML
            extentions between Internet Explorer and Mozilla (or Moz-based)
            browsers. It is an effort to provide a common interface for those
            extentions, bringing them closer to eachother. It was originally
            created to protect my sanity ;-)
         </p>
		  <p>
            Sarissa implements some of the DOM standard and Mozilla extentions 
            for IE and some IE extentions for Mozilla. Finally, it provides some 
            factory methods, for both browsers.
         </p>
    </div>
    <div class="section">
      <h3>
        <a id="getxmldom">How to obtain a DOM Document object</a>
      </h3>
      <p>
            Obtaining a DOM Document object is as easy as calling a factory
            method:
         </p>
      <pre xml:space="preserve">
// Get a browser spessific DOM Document objext
var oDomDoc = Sarissa.getDomDocument();
</pre>
      <p>
            Additionally, you can also pass two string parameters to that
            factory method. These parameters are a namespace and a local name
            respectively. Their combination builds the Document Element thus:
         </p>
      <pre xml:space="preserve">
var oDomDoc = Sarissa.getDomDocument("http://foo.org/ns/uri","foo");
</pre>
      <p>
          will build a representation of the following into memory:
	  </p>
      <pre xml:space="preserve">
&lt;foo xmlns="http://foo.org/ns/uri"&gt;&lt;/foo&gt;
</pre>
      <p>
            In Mozilla, calling the <code>Sarissa.getDomDocument</code> method
            as above equals to:
      </p>
      <pre xml:space="preserve">
var oDomDoc = document.implementation.createDocument("http://foo.org/ns/uri","foo", null);
</pre>
      <p>
            In the case you are using Internet Explorer, the
            <code>Sarissa.getDomDocument</code> method returns a DOM Document
            object, using the most recent MSXML ProgID available in your system
            for that Class. So supposing MSXML4.0 is available, the equal
            statement for IE is:
         </p>
      <pre xml:space="preserve">
var oDomDoc = new ActiveXObject("Msxml2.DOMDocument.4.0");
</pre>
      <p>
        <span class="bold">If</span> the arguments to the factory method
            include a namespace URI and node name, the proper DocumentElement
            is build and inserted in the Document object in IE as well.
         </p>
    </div>
    <div class="section">
      <h3>
        <a id="getxmlhttp">How to obtain an XMLHTTP Request object</a>
      </h3>
      <p>
            A factory method is also used to obtain an XMLHTTPRequest object:
         </p>
      <pre xml:space="preserve">
var xmlhttp = Sarissa.getXmlHttpRequest();
</pre>
      <p>
            In Moz, the above equals to:
         </p>
      <pre xml:space="preserve">
var xmlhttp = new XMLHttpRequest();
</pre>
      <p>
            For users under IE, an XMLHTTP object is returned using the most
            recent MSXML ProgID found in the client system. So, supposing that
            the user has MSXML4.0 installed, the call to
            <code>Sarissa.getXmlHttpRequest</code> equals to:
         </p>
      <pre xml:space="preserve">
var xmlhttp = new ActiveXObject("Msxml2.XMLHTTP.4.0");
</pre>
      <p>
            Further coding on XMLHTTP objects is the same for both browsers,
            so:
         </p>
      <pre xml:space="preserve">
var xmlhttp = Sarissa.getXmlHttpRequest();
xmlhttp.open("GET", "http://foo.org/someDocument.xml", false);
// if needed set header information 
// using the setRequestHeader method
xmlhttp.send(null);
alert(xmlhttp.responseXML.xml);
</pre>
      <p>
            will load the document from the server and then throw an alertbox
            with the contents of the file to your screen. XMLHTTP objects
            support both synchronous and asynchronous loading of remote XML
            documents (note the third parameter of the
            <code>xmlhttp.open</code> method above). In asynchronous loading,
            you will probably want to call a function to handle the object readystatechange 
			events, see if loading is completed and then do whatever. To do that, add your 
            onreadystatechange handler function before calling the <code>send</code> method. Something
            like:
         </p>
      <pre xml:space="preserve">
xmlhttp.onreadystatechange = function()
{
	if(xmlhttp.readyState == 4)
		alert("Finished loading!");
}
</pre>
    </div>
    <div class="section">
      <h3>
        <a id="loadremote">How to load an DOM Document Object from a remote
            source</a>
      </h3>
      <p>
            Loading a document is as simple as calling the <code>load</code>
            method of a DOM Document object, passing a URL as the parameter.
            Loading can be performed synchronously or asynchronously. This is
            controled by setting the <code>async</code> property of a DOM
            Document before calling the <code>load</code> method.The default
            value of the <code>async</code> property is true, resulting in
            asynchronous loading, meaning that the next statement is executed
            immediately. Setting it to false causes execution to freeze; the
            statement after the <code>load</code> will only be called when the
            document has fully loaded and parsed into memory.
         </p>
      <p class="note">
        <span class="bold">Note</span>: In Mozilla versions prior to 1.4, synchronous loading
            will only work for documents on a server, not the filesystem in the
            same machine as the browser. This is because I extended the
            <code>load</code> method to use an XMLHttpRequest internally to
            implement synchronous loading for DOM Document objects. In Mozilla 1.4 and 
			above this property is natively implemented.
         </p>
      <h4>
            Examples of synchronous/asynchronous loading
         </h4>
      <div>
        <h5>
          <a id="async">Asynchronous Loading</a>
        </h5>
        <pre xml:space="preserve">
var oDomDoc = Sarissa.getDomDocument();
oDomDoc.async = true; // this line can be ommited - true is the default
// we add a listener for the load event to know when loading is finished
function myHandler;
{
	if(oDomDoc.readyState == 4)
    alert(oDomDoc.xml);// show the file contents
};

oDomDoc.onreadystatechange = myHandler;
oDomDoc.load("someDocument.xml");
</pre>
      </div>
      <div>
        <h5>
          <a id="sync">Synchronous Loading</a>
        </h5>
        <pre xml:space="preserve">
var oDomDoc = Sarissa.getDomDocument();
oDomDoc.async = false; // this is the important part
oDomDoc.load("someDocument.xml");
alert(oDomDoc.xml);// show the file contents
</pre>
      </div>
    </div>
    <div class="section">
      <h3>
        <a id="loadstring">How to load an XML Document Object from an XML String</a>
      </h3>
      <p>
            You can also make a DOM Document "load" using an String
            variable with XML content. It's pretty simple using the
            <code>loadXML</code> method:
         </p>
      <pre xml:space="preserve">
var oDomDoc = Sarissa.getDomDocument();
var xmlString = "&lt;root&gt;my xml!&lt;/root&gt;";
oDomDoc.loadXML(xmlString);
alert(oDomDoc.xml);
</pre>
    </div>
    <div class="section">
      <h3>
        <a id="parseerror">How to check for parsing errors</a>
      </h3>
      <p>
            After a document has loaded, you can check for parsing errors using
            the <code>parseError</code> property. The property always gives an
            integer, anything other than zero signals an error.
         </p>
      <pre xml:space="preserve">
// ...
oDomDoc.async = false;
oDomDoc.load("someDocument.xml");
if(oDomDoc.parseError != 0)
   alert("not well formed or other error!");
else
   alert("loaded ok");
</pre>
		<p>
			You can also get a human-readable description of the error using 
			the Sarissa getParseErrorText method, passing the document as the argument: 
		</p>
		<pre>
Sarissa.getParseErrorText(oDomDoc);
</pre>
		<p>
			The method returns the error description as a simple string. 
			<span class="bold">Tip</span>: Wrap this string to a 
			<code>&quot;pre&quot;</code> element if you want to render it.
		</p>
    </div>
    <div class="section">
      <h3>
        <a id="transform">How to transform a DOM Document Object with XSLT</a>
      </h3>
      <p>
            Both Mozilla and IE provide JavaScript interfaces to control XSLT
            transformations thanks to Transformiix and MSXML3 (or above)
            respectively. MSXML3+ is available with IE6 or as a seperate
            instalation.
         </p>
      <p>
            The result of a transformation can be either a new DOM Document or
            an XML String.
         </p>
      <div>
        <h5>
          <a id="transformtoobject">How to store the transformation result to a DOM Object</a>
        </h5>
        <p>
               The example below demonstrates the use of the
               <code>transformNodeToObject</code> method to obtain the result
               tree as a DOM object:
            </p>
        <pre xml:space="preserve">
// get the source document
var oDomDoc = Sarissa.getDomDocument();
oDomDoc.async = false;
oDomDoc.load("someDocument.xml");

// get the stylesheet document
var oXslDoc = Sarissa.getDomDocument();
oXslDoc.async = false;
oXslDoc.load("aStylesheet.xsl");

// instantiate the result document
var oResult = Sarissa.getDomDocument();

// transform and store the results to oResult
oDomDoc.transformNodeToObject(oXslDoc, oResult);
</pre>
        <p>
               The two parameters passed to the method are the stylesheet and
               result DOM objects.
            </p>
      </div>
      <div>
        <h5>
          <a id="appendtopage">
          	How to insert the transformation result to a web page
          </a>
        </h5>
        <pre xml:space="preserve">
// continued from above: append transformation result to web page
// using the importNode (implemented for IE by Sarissa) and appendChild:
document.getElementById("some-id").appendChild(document.importNode(oResult.documentElement, true));
</pre>
       </div>
      <div>
        <h5>
          <a id="transformtostring">How to store the transformation result
               to a String object</a>
        </h5>
        <p>
               The example below demonstrates the use of the
               <code>transformNode</code> method to obtain the result tree as a
               String:
            </p>
        <pre xml:space="preserve">
// get the source document
var oDomDoc = Sarissa.getDomDocument();
oDomDoc.async = false;
oDomDoc.load("someDocument.xml");

// get the stylesheet document
var oXslDoc = Sarissa.getDomDocument();
oXslDoc.async = false;
oXslDoc.load("aStylesheet.xsl");

// transform and store the results to a string
var sResult = oDomDoc.transformNode(oXslDoc);
alert(sResult);
</pre>
        <p>
               The only parameter passed to <code>transformNode</code> is the
               stylesheet DOM.
            </p>
      </div>
      <div>
        <h5>
          <a id="xslparam">How to set XSLT parameters</a>
        </h5>
        <p>
               You can set XSLT parameters using using the
               Sarissa.setXslParameter factory method. The method takes three
               parameters, the Stylesheet Dom Object, the parameter name and
               the parameter value. The parameter value can be a String, Node
               or NodeList object. An simple Array of Element Nodes can also be
               handled.
            </p>
        <p>
               This method is in it's early stages, so any feedback would
               be appreciated. Currently working to add a namespace parameter
               so that the parameter name can be a QName.
            </p>
        <p class="note">
               <span class="bold">Note</span> that in case the parameter value is a string, it will be
               evaluated as an expression by the XSLT processor; there is a
               major difference betwen "foo" and
               "<span class="bold">'</span>foo<span class="bold">'</span>".
            </p>
        <p>
               Now, on to an example. Supposing that the stylesheet in our
               example above has the following global parameter:
            </p>
        <pre xml:space="preserve">
&lt;xsl:param name="title"/&gt;
</pre>
        <p>
               You can easily set and then perform the transformation like:
            </p>
        <pre xml:space="preserve">
var success = Sarissa.setXslParameter(oXslDoc, "title", "'My title'");
alert("Parameter set: " + success);
</pre>
        <p>
               The method returns true if the parameter was set properly, false
               otherwise.
            </p>
        <p>
               Ommiting a parameter value or setting it to <code>null</code>
               results in the parameter having no value, which is perfectly
               acceptable in XSLT since the language has no side effects.
            </p>
      </div>
      
      
      <div>
        <h5>
          <a id="reusablexslt">How to reuse stylesheets with the XSLTProcessor</a>
        </h5>
        <p>
        	Sarissa emulates Mozilla's XSLTProcessor for Internet Explorer.
        	This object allows reusability of stylsheets; with it you can use the same stylesheet 
        	on more than one source files. You use the XSLTProcessor to control transformations and 
        	set / get stylesheet parameters as in the following example:
        </p>
        <pre xml:space="preserve">
// create an instance of XSLTProcessor
var processor = new XSLTProcessor();

// create a DOM Document containing an XSLT stylesheet
var xslDoc = Sarissa.getDomDocument();
var xslStr = "&lt;?xml version='1.0' encoding='UTF-8'?&gt;"+
  	"&lt;xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform' &gt;"+
    	"&lt;xsl:output method='html' version='1.0' encoding='UTF-8' indent='yes'/&gt;"+
	"&lt;xsl:param name='title'&gt;&lt;xsl:value-of select=\"'default title'\"/&gt;&lt;/xsl:param&gt;"+
    	"&lt;xsl:template match='/'&gt;&lt;p class='test' title='{$title}'&gt;test&lt;/p&gt;&lt;/xsl:template&gt;&lt;xsl:template match='@*'&gt;"+
    	"&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;";
xslDoc.loadXML(xslStr);

// make the stylesheet reusable by importing it in the 
// XSLTProcessor
processor.importStylesheet(xslDoc);


// now XSLTProcessor is the 'proxy' for our stylesheet,
// the function below demonstrates usage
function test(paramValue) {
	// set a stylesheet parameter
	processor.setParameter(null, "title", paramValue);
    // create source document
    var xmlDoc = Sarissa.getDomDocument("http://foo.org/ns/uri","foo", null);
    // transform the document 
    var newDocument = processor.transformToDocument(xmlDoc);
    // show transformation results
    alert(newDocument.xml);
}


// test the above function
test("test 1");
</pre>
      </div>
    </div>
    <div class="section">
      <h3>
        <a id="xpath">How to use XPath from JavaScript to select Nodes from an XML Document</a>
      </h3>
      <p>
            Mozilla fully implements <a href="http://www.w3.org/TR/DOM-Level-3-XPath">DOM Level 3 XPath</a> so it was pretty trivial to implement IE's basic 
			<code>selectNodes</code> and <code>selectSingleNode</code> methods, with full namespaces support. 
			Actually IE also needs the proprietary <code>setProperty</code> method for it's XPath implementation to work. 
			<code>setProperty</code> is used for a number of things in IE. First you'll have to use it to make XPath available
			for a certain document:
         </p>
      <pre xml:space="preserve">
oDomDoc.setProperty("SelectionLanguage", "XPath");</pre>
      <p>In IE, using <code>selectNodes</code> or <code>selectSingleNode</code> without the above first will give an error. 
		Also, the same method with different parameters is used to allow IE to resolve namespace prefixes, for example:</p>
      <pre xml:space="preserve">
oDomDoc.setProperty("SelectionNamespaces", 
                    "xmlns:xhtml='http://www.w3.org/1999/xhtml'");
	</pre>
      <p>If you want to allow IE to resolve multiple namespace prefixes, use a space delimited list like:</p>
      <pre xml:space="preserve">
oDomDoc.setProperty("SelectionNamespaces", 
                    "xmlns:xhtml='http://www.w3.org/1999/xhtml' 
                     xmlns:xsl='http://www.w3.org/1999/XSL/Transform'")</pre>
      <p>Mozilla does not need any of the above. DOM L3 XPath is always available and namespaces are resolved err... automatically. 
		Below is an example of using <code>selectNodes</code> and <code>selectSingleNode</code> when Sarissa is available to provide 
		cross browser XPath functionality. For more documentation on these proprietary methods check with the documentation at the MSDN website (<a href="http://msdn.microsoft.com" title="link to Microsoft developer website">http://msdn.microsoft.com</a>).
		I'm not providing a URL for that as they constantly change their URLs.</p>
      <pre xml:space="preserve">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;Untitled&lt;/title&gt;
    &lt;script type="text/javascript" src="Sarissa_0-9b3.js"&gt;
    &lt;/script&gt;
    &lt;script type="text/javascript"&gt;
    &lt;!--
function testXpath()
{
    var xmlDoc = Sarissa.getDomDocument();
    var objNodeList;
    var xmlStr = "&lt;?xml version='1.0' encoding='UTF-8'?&gt;"+
        "&lt;xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'&gt;"+
        "&lt;xsl:output method='xml' version='1.0' encoding='UTF-8' indent='yes'/&gt;"+
        "&lt;xsl:template match='*'&gt;&lt;/xsl:template&gt;&lt;xsl:template match='@*'&gt;"+
        "&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;";
    xmlDoc.loadXML(xmlStr);
	
    <span style="bold">// the following two lines are needed for IE</span>
    xmlDoc.setProperty("SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
    xmlDoc.setProperty("SelectionLanguage", "XPath");
	
    testSelectNodesOn(xmlDoc, "//xsl:template");
    testSelectNodesOn(xmlDoc.documentElement, "//xsl:template");
    testSelectNodesOn((xmlDoc.documentElement.getElementsByTagName("*"))[0], "//xsl:template");
}
function testSelectNodesOn(domNode, sXpath)
{
    alert("testing selectNodes("+sXpath+") on a "+domNode);
    var objNodeList = domNode.selectNodes(sXpath);
    for(i=0;i&lt;objNodeList.length;i++)
        alert(objNodeList[i].xml);
    alert("testing selectSingleNode("+sXpath+") on a "+domNode);
    var oElem = domNode.selectSingleNode(sXpath);
    alert(oElem+"\n"+oElem.xml);
}
    //--&gt;
    &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;button onclick="testXpath()"&gt;test xpath&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
		</pre>
    </div>
	<!--p>
	<a href="http://sourceforge.net">
		<img src="http://sourceforge.net/sflogo.php?group_id=75155&amp;type=1" width="88" height="31" alt="SourceForge.net Logo" />
	</a>
	</p-->