/** * ==================================================================== * About * ==================================================================== * Sarissa cross browser XML library - DHTM/AJAX/Forms module * @version ${project.version} * @author: Copyright Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net * * This module contains some convenient DHTML, AJAX and Form utility methods based on Sarissa  * * ==================================================================== * Licence * ==================================================================== * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher,  * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher  * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If  * you make modifications under the ASL, i would appreciate it if you submitted those. * In case your copy of Sarissa does not include the license texts, you may find * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and  * <a href="http://www.apache.org">http://www.apache.org</a>. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY  * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE  * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE  * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *//** @private */Sarissa.updateCursor = function(oTargetElement, sValue) {    if(oTargetElement && oTargetElement.style && oTargetElement.style.cursor != undefined ){        oTargetElement.style.cursor = sValue;    };};/** * Asynchronously update an element with response of a GET request on the given URL.  Passing a configured XSLT  * processor will result in transforming and updating oNode before using it to update oTargetElement. * You can also pass a callback function to be executed when the update is finished. The function will be called as  * <code>functionName(oNode, oTargetElement);</code> * @addon * @param sFromUrl the URL to make the request to * @param oTargetElement the element to update * @param xsltproc (optional) the transformer to use on the returned *                  content before updating the target element with it * @param callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(oNode, oTargetElement)</code> * @param skipCache (optional) whether to skip any cache */Sarissa.updateContentFromURI = function(sFromUrl, oTargetElement, xsltproc, callback, skipCache) {    try{        Sarissa.updateCursor(oTargetElement, "wait");        var xmlhttp = new XMLHttpRequest();        xmlhttp.open("GET", sFromUrl, true);        function sarissa_dhtml_loadHandler() {            if (xmlhttp.readyState == 4) {                Sarissa.updateContentFromNode(xmlhttp.responseXML, oTargetElement, xsltproc, callback);            };        };        xmlhttp.onreadystatechange = sarissa_dhtml_loadHandler;        if (skipCache) {             var oldage = "Sat, 1 Jan 2000 00:00:00 GMT";             xmlhttp.setRequestHeader("If-Modified-Since", oldage);        };        xmlhttp.send("");    }    catch(e){        Sarissa.updateCursor(oTargetElement, "auto");        throw e;    };};/** * Update an element's content with the given DOM node. Passing a configured XSLT  * processor will result in transforming and updating oNode before using it to update oTargetElement. * You can also pass a callback function to be executed when the update is finished. The function will be called as  * <code>functionName(oNode, oTargetElement);</code> * @addon * @param oNode the URL to make the request to * @param oTargetElement the element to update * @param xsltproc (optional) the transformer to use on the given  *                  DOM node before updating the target element with it * @param callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(oNode, oTargetElement)</code> */Sarissa.updateContentFromNode = function(oNode, oTargetElement, xsltproc, callback) {    try {        Sarissa.updateCursor(oTargetElement, "wait");        Sarissa.clearChildNodes(oTargetElement);        // check for parsing errors        var ownerDoc = oNode.nodeType == Node.DOCUMENT_NODE?oNode:oNode.ownerDocument;        if(ownerDoc.parseError && ownerDoc.parseError != 0) {            var pre = document.createElement("pre");            pre.appendChild(document.createTextNode(Sarissa.getParseErrorText(ownerDoc)));            oTargetElement.appendChild(pre);        }        else {            // transform if appropriate            if(xsltproc) {                oNode = xsltproc.transformToDocument(oNode);            };            // be smart, maybe the user wants to display the source instead            if(oTargetElement.tagName.toLowerCase() == "textarea" || oTargetElement.tagName.toLowerCase() == "input") {                oTargetElement.value = new XMLSerializer().serializeToString(oNode);            }            else {                // ok that was not smart; it was paranoid. Keep up the good work by trying to use DOM instead of innerHTML                if(oNode.nodeType == Node.DOCUMENT_NODE || oNode.ownerDocument.documentElement == oNode) {                    oTargetElement.innerHTML = new XMLSerializer().serializeToString(oNode);                }                else{                    oTargetElement.appendChild(oTargetElement.ownerDocument.importNode(oNode, true));                };            };          };        if (callback) {            callback(oNode, oTargetElement);        };    }    catch(e) {            throw e;    }    finally{        Sarissa.updateCursor(oTargetElement, "auto");    };};Sarissa.formToQueryString = function(oForm){    var qs = "";    for(var i = 0;i < oForm.elements.length;i++) {        var oField = oForm.elements[i];        var sFieldName = oField.getAttribute("name") ? oField.getAttribute("name") : oField.getAttribute("id");         // ensure we got a proper name/id and that the field is not disabled        if(sFieldName &&             ((!oField.disabled) || oField.type == "hidden")) {            switch(oField.type) {                case "hidden":
                case "text":
                case "textarea":
                case "password":
                    qs += sFieldName + "=" + encodeURIComponent(oField.value) + "&";
                    break;
                case "select-one":
                    qs += sFieldName + "=" + encodeURIComponent(oField.options[oField.selectedIndex].value) + "&";
                    break;
                case "select-multiple":
                    for (var j = 0; j < oField.length; j++) {                        var optElem = oField.options[j];
                        if (optElem.selected == true) {
                            qs += sFieldName + "[]" + "=" + encodeURIComponent(optElem.value) + "&";
                        };
                     };
                     break;                case "checkbox":                case "radio":                    if(oField.checked) {                        qs += sFieldName + "=" + encodeURIComponent(oField.value) + "&";                    };                    break;
            };        };    };    // return after removing last '&'
    return qs.substr(0, qs.length - 1); };/** * Asynchronously update an element with response of an XMLHttpRequest-based emulation of a form submission. <p>The form <code>action</code> and  * <code>method</code> attributess will be followed. Passing a configured XSLT processor will result in  * transforming and updating the server response before using it to update the target element. * You can also pass a callback function to be executed when the update is finished. The function will be called as  * <code>functionName(oNode, oTargetElement);</code></p> * <p>Here is an example of using this in a form element:</p> * <pre name="code" class="xml">&lt;form action="/my/form/handler" method="post"  *     onbeforesubmit="Sarissa.updateContentFromForm(this, document.getElementById('targetId'))"&gt;<pre> * <p>If JavaScript is supported, the form will not be submitted. Instead, Sarissa will * scan the form and make an appropriate AJAX request, also adding a parameter  * to signal to the server that this is an AJAX call. The parameter is  * constructed as <code>Sarissa.REMOTE_CALL_FLAG = "=true"</code> so you can change the name in your webpage * simply by assigning another value to Sarissa.REMOTE_CALL_FLAG. If JavaScript is not supported * the form will be submitted normally. * @addon * @param oForm the form submition to emulate * @param oTargetElement the element to update * @param xsltproc (optional) the transformer to use on the returned *                  content before updating the target element with it * @param callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(oNode, oTargetElement)</code> * @param skipCache (optional) whether to skip any cache */Sarissa.updateContentFromForm = function(oForm, oTargetElement, xsltproc, callback) {    try{        Sarissa.updateCursor(oTargetElement, "wait");        // build parameters from form fields        var params = Sarissa.formToQueryString(oForm) + "&" + Sarissa.REMOTE_CALL_FLAG = "=true";        var xmlhttp = new XMLHttpRequest();        if(oForm.getAttribute("method") && oForm.getAttribute("method").toLowerCase() == "get") {            xmlhttp.open("GET", oForm.getAttribute("action")+"?"+params, true);        }        else{            http_request.open('POST', oForm.getAttribute("action"), true);            http_request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");            http_request.setRequestHeader("Content-length", params.length);            http_request.setRequestHeader("Connection", "close");        };        function sarissa_dhtml_loadHandler() {            if (xmlhttp.readyState == 4) {                Sarissa.updateContentFromNode(xmlhttp.responseXML, oTargetElement, xsltproc, callback);            };        };        xmlhttp.onreadystatechange = sarissa_dhtml_loadHandler;        xmlhttp.send("");    }    catch(e){        Sarissa.updateCursor(oTargetElement, "auto");        throw e;    };    return false;};